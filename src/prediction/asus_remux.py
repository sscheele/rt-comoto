#!/usr/bin/env python3

"""
Remuxes the tf fa
mes generated by the ASUS
skeleton trackerp
ackage into `JointTrajectoryMessage`s
and sends them out for the listener. Does spatial
and temporal resampling to get appropriate joints.
"""
import tf2_ros
import yaml
import numpy as np
import rospy

from trajectory_msgs.msg import JointTrajectoryPoint

# Expected names for the joints
JOINT_NAMES = [
    '0', '1', '2', '3', '4', '6', '7', '8', '9', '11', '12', '13', '14', '16', '17', '18', '19', '24', '25', '26', '27'
]
# period for reading from tf
READ_PD = 0.1
# camera-robot transformation matrix
TRANS_MATR = np.array(
[[-3.09919042e-01, 1.30777789e-01, 9.37422705e-01, 1.46495279e+00],
 [-8.00322580e-01, 4.56893153e-02,-9.28656519e-02,-9.71700104e-01],
 [ 4.27132586e-02,-7.27532989e-01, 1.96188935e-01, 8.95798856e-01],
 [ 2.22044605e-16, 4.44089210e-16, 5.55111512e-16, 1.00000000e+00]]
)
# TRANS_MATR = np.array(
# [[-7.56959918e-02, -1.46487732e-01,  1.00835348e+00,  1.68643459e+00],
#  [-8.12858421e-01,  3.11071349e-01, -1.57721292e-02, -9.86659366e-01],
#  [-1.54006340e-01, -7.90050484e-01,  2.61622877e-01,  9.47804295e-01],
#  [ 1.55431223e-15,  3.88578059e-16, -4.99600361e-16,  1.00000000e+00]]
# )

# Joints:
# 0 - Root (pelvis)
# 1 - Right hip 
# 2 - Right knee
# 3 - Right ankle
# 4 - Right foot 
# 6 - left hip
# 7 - left knee
# 8 - right ankle
# 9 - left foot
# 11 - duplicate of 0
# 12 - center spine
# 13 - shoulder spine/base of neck
# 14 - bottom of head
# 16 - duplicate of 13
# 17 - left shoulder
# 18 - left elbow
# 19 - left wrist
# 24 - duplicate of 13
# 25 - right shoulder
# 26 - right elbow
# 27 - right wrist

# ['tracker/user_1/head', 'tracker/user_1/right_hip', 
# 'tracker/user_1/left_hand', 'tracker/user_1/torso', 
# 'tracker/user_1/right_elbow', 'tracker/user_1/left_knee', 
# 'tracker/user_1/left_foot', 'tracker/user_1/left_elbow', 
# tracker/user_1/right_shoulder', 'tracker/user_1/neck', 
# 'tracker/user_1/right_foot', 'tracker/user_1/left_hip', 
# 'tracker/user_1/right_knee', 'tracker/user_1/right_hand', 
# 'tracker/user_1/left_shoulder']

def do_transform(A, posns):
    """
    A: (4,4)
    posns: (n, 3)
    
    return: new_posns (n, 3)
    """
    n = posns.shape[0]
    x = np.hstack((posns, np.ones((n, 1)))).T
    trans = np.matmul(A, x)
    return trans[:-1,:].T

def expand_skeleton(posn_dict):
    """
    In the case that posn_dict is missing joints
    (eg: legs are beneath a table), tries to
    artificially add plausible positions to
    complete the skeleton. Assumes that both arms,
    head, torso, and shoulders are in view.
    """
    expected_keys = ['head', 'left_hand', 
        'torso', 'right_elbow', 'left_elbow', 
        'right_shoulder', 'neck', 'right_hand', 
        'left_shoulder']
    for key in expected_keys:
        posn_dict[key]
    ret_val = posn_dict.copy()
    if 'right_hip' not in ret_val:
        # put hip under shoulder
        x = np.copy(ret_val['right_shoulder'])
        x[2] = 0.6*x[2]
        ret_val['right_hip'] = x
    if 'left_hip' not in ret_val:
        # put hip under shoulder
        x = np.copy(ret_val['left_shoulder'])
        x[2] = 0.6*x[2]
        ret_val['left_hip'] = x
    if 'right_knee' not in ret_val:
        x = np.copy(ret_val['right_hip'])
        x[2] = 0.5*x[2]
        ret_val['right_knee'] = x
    if 'left_knee' not in ret_val:
        x = np.copy(ret_val['left_hip'])
        x[2] = 0.5*x[2]
        ret_val['left_knee'] = x
    if 'right_foot' not in ret_val:
        x = np.copy(ret_val['right_knee'])
        x[2] = 0
        ret_val['right_foot'] = x
    if 'left_foot' not in ret_val:
        x = np.copy(ret_val['left_knee'])
        x[2] = 0
        ret_val['left_foot'] = x
    return ret_val
    

def get_potr_skel(trans_dict):
    """
    trans_dict should map keys to transforms

    returns a (21, 3) numpy array containing
    the skeleton as expected by potr
    """
    posn_dict = { x: np.array([
                    trans_dict[x].transform.translation.x,
                    trans_dict[x].transform.translation.y,
                    trans_dict[x].transform.translation.z]) 
                for x in trans_dict.keys() }

    posn_dict = expand_skeleton(posn_dict)
    # after expansion, should have all joints
    expected_keys = ['head', 'right_hip', 
        'left_hand', 'torso', 
        'right_elbow', 'left_knee', 
        'left_foot', 'left_elbow', 
        'right_shoulder', 'neck', 
        'right_foot', 'left_hip', 
        'right_knee', 'right_hand', 
        'left_shoulder']
    for key in expected_keys:
        posn_dict[key] # throw KeyError if not here
    

    assert(len(JOINT_NAMES) == 21)
    ret_val = np.zeros((21, 3)) # a 3D position for every joint

    # NOTE: the camera confuses left and right, so they're switched here!
    
    # pelvis
    ret_val[0,:] = (posn_dict['right_hip'] + posn_dict['left_hip'])/2.0
    ret_val[1,:] = posn_dict['left_hip']
    ret_val[2,:] = posn_dict['left_knee']
    # ankle
    ret_val[3,:] = posn_dict['left_foot']
    # this is supposed to be in front of the ankle
    # but we don't have it so :)
    ret_val[4,:] = posn_dict['left_foot']
    ret_val[5,:] = posn_dict['right_hip']
    ret_val[6,:] = posn_dict['right_knee']
    # ankle
    ret_val[7,:] = posn_dict['right_foot']
    # this is supposed to be in front of the ankle
    # but we don't have it so :)
    ret_val[8,:] = posn_dict['right_foot']
    ret_val[9,:] = ret_val[0,:] # duplicate pelvis
    ret_val[10,:] = posn_dict['torso']
    ret_val[11,:] = posn_dict['neck']
    ret_val[12,:] = posn_dict['head']
    ret_val[13,:] = ret_val[11,:] # duplicate neck
    ret_val[14,:] = posn_dict['right_shoulder']
    ret_val[15,:] = posn_dict['right_elbow']
    ret_val[16,:] = posn_dict['right_hand']
    ret_val[17,:] = ret_val[11,:] # second duplicate neck
    ret_val[18,:] = posn_dict['left_shoulder']
    ret_val[19,:] = posn_dict['left_elbow']
    ret_val[20,:] = posn_dict['left_hand']

    ret_val = do_transform(TRANS_MATR, ret_val)

    return ret_val

class SkeletonBroadcaster:
    def __init__(self, posn_pub):
        self.posn_pub = posn_pub
        
        self.tf_buf = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buf)

    def read_skel_cb(self, evt):
        """
        Timer callback to read and transform the user skeleton
        Transforms morphology and applies filter if possible 
        """
        tf_skel_map = get_human_points(self.tf_buf)
        if len(tf_skel_map) == 0: # transforms not available yet
            return

        potr_skel_vec = None
        try:
            potr_skel_vec = get_potr_skel(tf_skel_map).ravel()
        except KeyError:
            print("Joints not present, can't read skeleton")
            return

        est_posn = potr_skel_vec

        pt = JointTrajectoryPoint()
        pt.positions = list(est_posn)
        self.posn_pub.publish(pt)

def get_human_points(tf_buffer):
    """
    Returns a dictionary mapping joint names (eg: 'head') to 3D points
    """
    frames_dict = yaml.safe_load(tf_buffer.all_frames_as_yaml())
    frames_list = list(frames_dict.keys())

    # for now, assume only 1 user's transforms are available
    frames_list = [x for x in frames_list if x.startswith('tracker/user_1')]
    if len(frames_list) < 7:
        return {}
    
    # trans_dict will map things like "head" to appropriate transforms
    trans_dict = { x.split('/')[-1]: tf_buffer.lookup_transform(x, 
                'tracker_depth_frame', rospy.Time()) 
                for x in frames_list }
    
    return trans_dict
    

if __name__ == "__main__":
    # allow time for ros init
    rospy.init_node('asus_remux')
    posn_pub = rospy.Publisher('human_posn', JointTrajectoryPoint, queue_size=1)
    skel_broad = SkeletonBroadcaster(posn_pub)
    rospy.Timer(rospy.Duration(READ_PD), skel_broad.read_skel_cb)
    rospy.spin()