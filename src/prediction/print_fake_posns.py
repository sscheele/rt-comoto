#!/usr/bin/env python3

"""
Remuxes the tf fa
mes generated by the ASUS
skeleton trackerp
ackage into `JointTrajectoryMessage`s
and sends them out for the listener. Does spatial
and temporal resampling to get appropriate joints.
"""
import tf2_ros
import yaml
import numpy as np
import rospy
from math import floor
import time

from scipy.interpolate import CubicSpline
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

# Expected names for the joints
JOINT_NAMES = [
    '0', '1', '2', '3', '4', '6', '7', '8', '9', '11', '12', '13', '14', '16', '17', '18', '19', '24', '25', '26', '27'
]
# period for reading from tf
IN_DT = 0.05
# sampling period for the human trajectories broadcast
OUT_TRAJ_DT = 0.04
# time between trajectory broadcasts
OUT_DT = 0.2
assert(OUT_DT % IN_DT == 0)

TRANS_MATR = np.array(
[[ 7.81059721e-01, -5.22576879e-01,  1.03970495e+00,  1.81755041e+00],
 [-8.36281788e-01,  5.20205418e-02,  2.55003337e-01, -2.11426498e-01],
 [ 3.75858265e-02, -1.13200641e-01,  2.08870212e-02,  2.38749544e-01],
 [ 1.05210979e-15,  6.66133815e-16, -5.12068686e-16,  1.00000000e+00]])
# Joints:
# 0 - Root (pelvis)
# 1 - Right hip 
# 2 - Right knee
# 3 - Right ankle
# 4 - Right foot 
# 6 - left hip
# 7 - left knee
# 8 - right ankle
# 9 - left foot
# 11 - duplicate of 0
# 12 - center spine
# 13 - shoulder spine/base of neck
# 14 - bottom of head
# 16 - duplicate of 13
# 17 - left shoulder
# 18 - left elbow
# 19 - left wrist
# 24 - duplicate of 13
# 25 - right shoulder
# 26 - right elbow
# 27 - right wrist

# ['tracker/user_1/head', 'tracker/user_1/right_hip', 
# 'tracker/user_1/left_hand', 'tracker/user_1/torso', 
# 'tracker/user_1/right_elbow', 'tracker/user_1/left_knee', 
# 'tracker/user_1/left_foot', 'tracker/user_1/left_elbow', 
# tracker/user_1/right_shoulder', 'tracker/user_1/neck', 
# 'tracker/user_1/right_foot', 'tracker/user_1/left_hip', 
# 'tracker/user_1/right_knee', 'tracker/user_1/right_hand', 
# 'tracker/user_1/left_shoulder']

def do_transform(A, posns):
    """
    A: (4,4)
    posns: (n, 3)
    """
    n = posns.shape[0]
    x = np.hstack((posns, np.ones((n, 1)))).T
    trans = np.matmul(A, x)
    return trans[:-1,:].T

def expand_skeleton(posn_dict):
    """
    In the case that posn_dict is missing joints
    (eg: legs are beneath a table), tries to
    artificially add plausible positions to
    complete the skeleton. Assumes that both arms,
    head, torso, and shoulders are in view.
    """
    expected_keys = ['head', 'left_hand', 
        'torso', 'right_elbow', 'left_elbow', 
        'right_shoulder', 'neck', 'right_hand', 
        'left_shoulder']
    for key in expected_keys:
        posn_dict[key]
    ret_val = posn_dict.copy()
    if 'right_hip' not in ret_val:
        # put hip under shoulder
        x = np.copy(ret_val['right_shoulder'])
        x[2] = 0.6*x[2]
        ret_val['right_hip'] = x
    if 'left_hip' not in ret_val:
        # put hip under shoulder
        x = np.copy(ret_val['left_shoulder'])
        x[2] = 0.6*x[2]
        ret_val['left_hip'] = x
    if 'right_knee' not in ret_val:
        x = np.copy(ret_val['right_hip'])
        x[2] = 0.5*x[2]
        ret_val['right_knee'] = x
    if 'left_knee' not in ret_val:
        x = np.copy(ret_val['left_hip'])
        x[2] = 0.5*x[2]
        ret_val['left_knee'] = x
    if 'right_foot' not in ret_val:
        x = np.copy(ret_val['right_knee'])
        x[2] = 0
        ret_val['right_foot'] = x
    if 'left_foot' not in ret_val:
        x = np.copy(ret_val['left_knee'])
        x[2] = 0
        ret_val['left_foot'] = x
    return ret_val
    

def fake_skeleton(trans_dict):
    """
    trans_dict should map keys to transforms

    returns a (21, 3) numpy array containing
    the skeleton as expected by potr
    """
    posn_dict = { x: np.array([
                    trans_dict[x].transform.translation.x,
                    trans_dict[x].transform.translation.y,
                    trans_dict[x].transform.translation.z]) 
                for x in trans_dict.keys() }

    posn_dict = expand_skeleton(posn_dict)
    # after expansion, should have all joints
    expected_keys = ['head', 'right_hip', 
        'left_hand', 'torso', 
        'right_elbow', 'left_knee', 
        'left_foot', 'left_elbow', 
        'right_shoulder', 'neck', 
        'right_foot', 'left_hip', 
        'right_knee', 'right_hand', 
        'left_shoulder']
    for key in expected_keys:
        posn_dict[key] # throw KeyError if not here
    

    assert(len(JOINT_NAMES) == 21)
    ret_val = np.zeros((21, 3)) # a 3D position for every joint
    # pelvis
    ret_val[0,:] = (posn_dict['left_hip'] + posn_dict['right_hip'])/2.0
    ret_val[1,:] = posn_dict['right_hip']
    ret_val[2,:] = posn_dict['right_knee']
    # ankle
    ret_val[3,:] = posn_dict['right_foot']
    # this is supposed to be in front of the ankle
    # but we don't have it so :)
    ret_val[4,:] = posn_dict['right_foot']
    ret_val[5,:] = posn_dict['left_hip']
    ret_val[6,:] = posn_dict['left_knee']
    # ankle
    ret_val[7,:] = posn_dict['left_foot']
    # this is supposed to be in front of the ankle
    # but we don't have it so :)
    ret_val[8,:] = posn_dict['left_foot']
    ret_val[9,:] = ret_val[0,:] # duplicate pelvis
    ret_val[10,:] = posn_dict['torso']
    ret_val[11,:] = posn_dict['neck']
    ret_val[12,:] = posn_dict['head']
    ret_val[13,:] = ret_val[11,:] # duplicate neck
    ret_val[14,:] = posn_dict['left_shoulder']
    ret_val[15,:] = posn_dict['left_elbow']
    ret_val[16,:] = posn_dict['left_hand']
    ret_val[17,:] = ret_val[11,:] # second duplicate neck
    ret_val[18,:] = posn_dict['right_shoulder']
    ret_val[19,:] = posn_dict['right_elbow']
    ret_val[20,:] = posn_dict['right_hand']

    ret_val = do_transform(TRANS_MATR, ret_val)

    return ret_val

def spline_traj(traj, sample_rate=20, goal_rate=25):
    """
    Spline a human trajectory to resample (probably upsample) it
    traj should be an array of numpy arrays of shape (21, 3)
    sample_rate: sampling rate in hz
    goal_rate: goal rate in hz
    """
    traj = np.asarray(traj) # (n_sample, 21, 3)
    assert(len(traj.shape) == 3)
    assert(traj.shape[0] > 1)
    assert(traj.shape[1:] == (21, 3))

    x_in = np.linspace(0, 1, traj.shape[0]) 
    n_out = int((goal_rate/sample_rate)*traj.shape[0])
    x_out = np.linspace(0, 1, n_out) # 2 sec + t=0

    ret_val = np.empty((n_out, 21, 3))

    for joint in range(21):
        for dim in range(3):
            # spline = CubicSpline(x_in, traj[:,joint,dim])
            # ret_val[:,joint,dim] = spline(x_out)
            ret_val[:,joint,dim] = np.interp(x_out, x_in, traj[:,joint,dim])
    
    return ret_val

def print_static_code(posn_dict):
    base_tmplt = '<node pkg="tf" type="static_transform_publisher" name="'
    for name in posn_dict.keys():
        posn = posn_dict[name]
        line = base_tmplt+name+'_broadcaster" args="'
        line += '%f %f %f 0 0 0 /tracker_depth_frame /user_1/%s 100" />' % (
            posn[0], posn[1], posn[2], name)
        print(line)
        
def do_trans_print():
    rospy.init_node('asus_remux')
    traj_pub = rospy.Publisher('human_traj', JointTrajectory, queue_size=10)

    rate = rospy.Rate(1/IN_DT)
    n_steps = 0
    tf_buffer = tf2_ros.Buffer()
    tf_listener = tf2_ros.TransformListener(tf_buffer)
    skel_buf = []

    # initial sleep to get data
    rate.sleep()
    while True:
        frames_dict = yaml.safe_load(tf_buffer.all_frames_as_yaml())
        frames_list = list(frames_dict.keys())

        # for now, assume only 1 user's transforms are available
        frames_list = [x for x in frames_list if x.startswith('tracker/')]
        if len(frames_list) < 7:
            rate.sleep()
            continue
        
        # trans_dict will map things like "head" to appropriate transforms
        trans_dict = { x.split('/')[-1]: tf_buffer.lookup_transform(x, 
                    'tracker_depth_frame', rospy.Time()) 
                    for x in frames_list }
        posn_dict = { x: np.array([
                    trans_dict[x].transform.translation.x,
                    trans_dict[x].transform.translation.y,
                    trans_dict[x].transform.translation.z]) 
                for x in trans_dict.keys() }
        posn_dict = expand_skeleton(posn_dict)
        print_static_code(posn_dict)
        print("==============")

def main():
    """
    - Dumb ROS setup
    - Every 50ms, get the latest human pose and fake
    it into the skeleton structure expected by POTR
    - Every 350ms after the first 2 sec, spline together 
    human trajectory, resample to 25fps, and send to listener
    - Every 2 sec, clear human trajectory buffer
    """
    rospy.init_node('asus_remux')
    traj_pub = rospy.Publisher('human_traj', JointTrajectory, queue_size=10)

    rate = rospy.Rate(1/IN_DT)
    n_steps = 0
    tf_buffer = tf2_ros.Buffer()
    tf_listener = tf2_ros.TransformListener(tf_buffer)
    skel_buf = []

    buf_time = 2.0
    buf_len = int(buf_time/IN_DT) + 1
    
    # initial sleep to get data
    rate.sleep()
    print("Starting!!")
    while True:
        frames_dict = yaml.safe_load(tf_buffer.all_frames_as_yaml())
        frames_list = list(frames_dict.keys())

        # for now, assume only 1 user's transforms are available
        frames_list = [x for x in frames_list if x.startswith('tracker/')]
        if len(frames_list) < 7:
            rate.sleep()
            continue
        # trans_dict will map things like "head" to appropriate transforms
        trans_dict = { x.split('/')[-1]: tf_buffer.lookup_transform(x, 
                    'tracker_depth_frame', rospy.Time()) 
                    for x in frames_list }
        
        try:
            skel_buf.append(fake_skeleton(trans_dict))
        except KeyError:
            continue
        
        if len(skel_buf) > buf_len: # 2 seconds at 20fps, plus t=0
            skel_buf = skel_buf[1:]

        # every 350 ms after the first 2 sec
        if n_steps % 7 == 6 and len(skel_buf) == buf_len:
            # spline and resample trajectory
            traj = spline_traj(skel_buf, sample_rate=1/IN_DT, goal_rate=1/OUT_TRAJ_DT)
            
            # assemble JointTrajectoryMessage
            joint_pts = []
            traj_vec = traj.reshape((traj.shape[0], -1))
            for i in range(traj_vec.shape[0]):
                pt = JointTrajectoryPoint()
                pt.positions = list(traj_vec[i,:].ravel())
                
                pt.time_from_start = rospy.Duration(i*OUT_TRAJ_DT)
                joint_pts.append(pt)
            traj_msg = JointTrajectory()
            traj_msg.joint_names = JOINT_NAMES
            traj_msg.points = joint_pts

            # send to predictor
            traj_pub.publish(traj_msg)
        
        if rospy.is_shutdown():
            break

        n_steps += 1
        rate.sleep()

if __name__ == "__main__":
    # allow time for ros init
    time.sleep(1)
    # do_trans_print()
    main()
